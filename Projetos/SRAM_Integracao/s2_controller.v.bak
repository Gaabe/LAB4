// Copyright (C) 1991-2016 Altera Corporation. All rights reserved.
// Your use of Altera Corporation's design tools, logic functions 
// and other software and tools, and its AMPP partner logic 
// functions, and any output files from any of the foregoing 
// (including device programming or simulation files), and any 
// associated documentation or information are expressly subject 
// to the terms and conditions of the Altera Program License 
// Subscription Agreement, the Altera Quartus Prime License Agreement,
// the Altera MegaCore Function License Agreement, or other 
// applicable license agreement, including, without limitation, 
// that your use is for the sole purpose of programming logic 
// devices manufactured by Altera and sold by Altera or its 
// authorized distributors.  Please refer to the applicable 
// agreement for further details.

// Generated by Quartus Prime Version 16.0.0 Build 211 04/27/2016 SJ Lite Edition
// Created on Sun Sep 04 21:28:08 2016

// synthesis message_off 10175

`timescale 1ns/1ns

module s2_controller (
    reset_n,clk,sp0_en,sp1_en,sp2_en,sp3_en,valid_rd,
    dmux_en,mux_sel[1:0],pipeline_rst,rd_en);

    input reset_n;
    input clk;
    input sp0_en;
    input sp1_en;
    input sp2_en;
    input sp3_en;
    input valid_rd;
    tri0 reset_n;
    tri0 sp0_en;
    tri0 sp1_en;
    tri0 sp2_en;
    tri0 sp3_en;
    tri0 valid_rd;
    output dmux_en;
    output [1:0] mux_sel;
    output pipeline_rst;
    output rd_en;
    reg dmux_en;
    reg [1:0] mux_sel;
    reg pipeline_rst;
    reg rd_en;
    reg [9:0] fstate;
    reg [9:0] reg_fstate;
    parameter startup=0,write0=1,read1=2,idle=3,read0=4,write2=5,read3=6,write3=7,write1=8,read2=9;

    always @(posedge clk)
    begin
        if (clk) begin
            fstate <= reg_fstate;
        end
    end

    always @(fstate or reset_n or sp0_en or sp1_en or sp2_en or sp3_en or valid_rd)
    begin
        if (~reset_n) begin
            reg_fstate <= startup;
            dmux_en <= 1'b0;
            mux_sel <= 2'b00;
            pipeline_rst <= 1'b0;
            rd_en <= 1'b0;
        end
        else begin
            dmux_en <= 1'b0;
            mux_sel <= 2'b00;
            pipeline_rst <= 1'b0;
            rd_en <= 1'b0;
            case (fstate)
                startup: begin
                    if (sp0_en)
                        reg_fstate <= read0;
                    else if (~(sp0_en))
                        reg_fstate <= idle;
                    // Inserting 'else' block to prevent latch inference
                    else
                        reg_fstate <= startup;

                    dmux_en <= 1'b0;

                    rd_en <= 1'b0;

                    pipeline_rst <= 1'b1;

                    mux_sel <= 2'b00;
                end
                write0: begin
                    if (sp1_en)
                        reg_fstate <= read1;
                    else if (~(sp1_en))
                        reg_fstate <= idle;
                    // Inserting 'else' block to prevent latch inference
                    else
                        reg_fstate <= write0;

                    dmux_en <= 1'b1;

                    rd_en <= 1'b1;

                    pipeline_rst <= 1'b0;

                    mux_sel <= 2'b00;
                end
                read1: begin
                    if (~(valid_rd))
                        reg_fstate <= read1;
                    else if (valid_rd)
                        reg_fstate <= write1;
                    // Inserting 'else' block to prevent latch inference
                    else
                        reg_fstate <= read1;

                    dmux_en <= 1'b0;

                    rd_en <= 1'b1;

                    pipeline_rst <= 1'b0;

                    mux_sel <= 2'b01;
                end
                idle: begin
                    reg_fstate <= idle;

                    dmux_en <= 1'b0;

                    rd_en <= 1'b0;

                    pipeline_rst <= 1'b0;

                    mux_sel <= 2'b00;
                end
                read0: begin
                    if (valid_rd)
                        reg_fstate <= write0;
                    else if (~(valid_rd))
                        reg_fstate <= read0;
                    // Inserting 'else' block to prevent latch inference
                    else
                        reg_fstate <= read0;

                    dmux_en <= 1'b0;

                    rd_en <= 1'b1;

                    pipeline_rst <= 1'b0;

                    mux_sel <= 2'b00;
                end
                write2: begin
                    if (~(sp3_en))
                        reg_fstate <= idle;
                    else if (sp3_en)
                        reg_fstate <= read3;
                    // Inserting 'else' block to prevent latch inference
                    else
                        reg_fstate <= write2;

                    dmux_en <= 1'b1;

                    rd_en <= 1'b1;

                    pipeline_rst <= 1'b0;

                    mux_sel <= 2'b10;
                end
                read3: begin
                    if (valid_rd)
                        reg_fstate <= write3;
                    else if (~(valid_rd))
                        reg_fstate <= read3;
                    // Inserting 'else' block to prevent latch inference
                    else
                        reg_fstate <= read3;

                    dmux_en <= 1'b0;

                    rd_en <= 1'b1;

                    pipeline_rst <= 1'b0;

                    mux_sel <= 2'b11;
                end
                write3: begin
                    reg_fstate <= idle;

                    dmux_en <= 1'b1;

                    rd_en <= 1'b1;

                    pipeline_rst <= 1'b0;

                    mux_sel <= 2'b11;
                end
                write1: begin
                    if (~(sp2_en))
                        reg_fstate <= idle;
                    else if (sp2_en)
                        reg_fstate <= read2;
                    // Inserting 'else' block to prevent latch inference
                    else
                        reg_fstate <= write1;

                    dmux_en <= 1'b1;

                    rd_en <= 1'b1;

                    pipeline_rst <= 1'b0;

                    mux_sel <= 2'b01;
                end
                read2: begin
                    if (~(valid_rd))
                        reg_fstate <= read2;
                    else if (valid_rd)
                        reg_fstate <= write2;
                    // Inserting 'else' block to prevent latch inference
                    else
                        reg_fstate <= read2;

                    dmux_en <= 1'b0;

                    rd_en <= 1'b1;

                    pipeline_rst <= 1'b0;

                    mux_sel <= 2'b10;
                end
                default: begin
                    dmux_en <= 1'bx;
                    mux_sel <= 2'bxx;
                    pipeline_rst <= 1'bx;
                    rd_en <= 1'bx;
                    $display ("Reach undefined state");
                end
            endcase
        end
    end
endmodule // s2_controller
